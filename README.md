# CIRCOM 101


## About the Repository
<img width="867" alt="image" src="https://github.com/srv-smn/circom-101/assets/86356248/0a1a5d94-1180-4fb6-b9c3-1244c3b18dbc">

This branch of the repository contains the code for implementing a `mimc` hashing function in circom and solidity.
We had choosen the power of 5 with 10 rounds
`(x + k + ci) power 5` for `10 times`
here
- k is a constant provided by user.
- c is a constant generated by system which will change in each round(ie. we have 10 rounds). It will start with 0.

`generate_bignumber.js` contains the code to generate the very large random number. Which we will use as `c` for each round. we the the first value of the array of `c` to `0` as acc to mimc `c[0]` should be `0`

`mimc.sol` is the solidity implementation of mimc, here we have used `p` as `21888242871839275222246405745257275088548364400416034343698204186575808495617` because it is defined in `EIP196`. Since from sol `0.8.0` overflow issue has been resolved we need to manually round off the number into the prime finite range. so we are using `addmod` and `mulmod` .

**Also want to point out that MiMC is circuit-friendly (therefore ZKP friendly), meaning it won't require a tremendous amount of constraints when converted to R1CS. This is thanks to the fact that MiMC uses addition and multiplication to computer the result, making it readily convertible to a addition/multiplication circuit. Hashing functions such as Keccak256, when turned into a circuit, will require 20K+ constraints, making it ZKP-UNfriendly. This is due to Keccak256 having a great deal of bits SELECTION. Circuits must be static when implemented, therefore selection can only be achieved by boolean functions (0/1 switching coefficients), which makes the # of constraints balloon rapidly.**

## Getting Started

To create a new `package.json`, run the following command:

```bash
npm init -y
```

Next, install **circom2** and **snarkjs** using npm:

```npm install circom2 snarkjs```

### Creating the Circuit

Let's create the `circuit.circom` file, which contains the circuit's logic.

### Compiling the Circuit
Compile the circuit using the following command:

```npx circom2 circuit.circom --r1cs --wasm```

Here:

```circuit.circom is the circuit file name.
--r1cs specifies the circuit type as R1CS.
--wasm is the output type
```
It which generates a new folder containing a **JavaScript file** for this circuit(wasm) along with two utility files.
Generating the Witness

### To run the witness file, use the following command:

```node circuit_js/generate_witness.js circuit_js/circuit.wasm input.json witness.wtns```

Here:

- circuit_js/generate_witness.js is the file that we want to run.
- circuit_js/circuit.wasm is the circuit wasm file we are feeding to the JavaScript file.
- input.json contains the input for the circuit.
- witness.wtns is the output file that contains the witness.

### Sample input.json file

```
{
    "x": 2,
    "y": 3
}
```

After running the witness generation command, you'll get a binary witness file. To convert it to JSON format, use:


`npx snarkjs wtns export json witness.wtns witness.json`

### Witness file (witness.json)
```
[
 "1",
 "47",
 "2",
 "3",
 "4",
 "12",
 "9"
]
```

The witness file is structured as follows: The first number is always one, representing constant operations within the circuit. This number can be ignored. Next comes the output, which, in this case, is only one value: 47.

To verify our understanding, let's quickly calculate the output based on the given inputs, where x = 2 and y = 3. The result is 47, which matches the correct output.

After the output, the witness file contains the inputs (2 and 3) followed by all the intermediate witness values. The number of witnesses in the file will always be the same as the number of constraints during the compilation, minus one. The reason for this may be related to the degree of freedom in a constraint system, although it's not entirely certain.
